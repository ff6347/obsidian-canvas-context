# Journal: 2025-10-15

## Issue #66 Complete: CanvasService UINotificationAdapter Integration

Successfully completed the migration of CanvasService to use the UINotificationAdapter pattern, continuing the testable architecture refactoring across all services.

### What We Did

**Problem**: CanvasService was using fallback values and direct Notice calls instead of proper error handling through the UINotificationAdapter pattern that other services use.

**Solution**: Integrated UINotificationAdapter into CanvasService following the established pattern from Issues #55-#57, #60, and #65.

### Changes Made

1. **CanvasService** (`src/services/canvas-service.ts`):
   - Added `UINotificationAdapter` to constructor parameters
   - Replaced fallback values (`sourceNodeData?.x ?? 100`) with proper null checks
   - Added error notification when source node not found
   - Replaced all direct `Notice` calls with `notificationAdapter` calls

2. **Main Plugin** (`src/main.ts`):
   - Updated CanvasService instantiation to pass `notificationAdapter`

3. **Test Files** (4 files updated):
   - `canvas-service-response-node.test.ts` - Now uses `TestNotificationAdapter`
   - `canvas-service-canvas-info.test.ts` - Added mock adapter
   - `canvas-service-context.test.ts` - Added mock adapter
   - `canvas-service.test.ts` - Added mock adapter

4. **Bonus Fix**:
   - Fixed pre-existing TypeScript errors in `api-key-configuration-service.test.ts`
   - Added non-null assertions for array access verified by length checks

### Testing Results

- ✅ All 305 tests pass
- ✅ TypeScript compilation succeeds
- ✅ Lint passes (only pre-existing style warnings)
- ✅ Issue #66 acceptance criteria met

### Commits

Created two atomic commits following conventional commit format:

1. `fix: integrate UINotificationAdapter into CanvasService` (74c17fa)
   - Core refactoring with all related changes
   - Closes #66

2. `fix: add non-null assertions to api-key-configuration-service tests` (681ff4b)
   - Unrelated TypeScript error fixes
   - Kept separate for clean history

### Architecture Progress

This completes the UINotificationAdapter pattern integration for all main plugin services:

- ✅ InferenceService
- ✅ MenuService
- ✅ CanvasService (today)
- ✅ ApiKeyConfigurationService

The codebase now has consistent error handling across all services, making it easier to test and maintain.

### Next Steps

Remaining work tracked in GitHub Issues:

- **Issue #67**: Replace remaining direct Notice usage in other services
- Continue applying layered architecture pattern to modal and settings services
- Update test structure organization

### Key Learnings

1. **Pattern Consistency**: Following the same adapter pattern across services makes refactoring predictable and reliable

2. **Atomic Commits**: Separating unrelated fixes (TypeScript errors) from main refactoring work keeps git history clean and reviewable

3. **Test-Driven Refactoring**: Having comprehensive tests (305 passing) gives confidence that refactoring preserves functionality

4. **Error Handling Evolution**: Moving from fallback values to explicit error handling improves user experience - users now see clear error messages instead of silent failures

## Documentation Restructuring

### Plans Structure Created

Reorganized PLAN.md into focused sub-plans for better navigation:

- `docs/plans/architecture.md` - Service architecture and design patterns
- `docs/plans/canvas-algorithm.md` - Tree walking algorithm and frontmatter system
- `docs/plans/providers.md` - LLM provider integration and management
- `docs/plans/testing-strategy.md` - Testing approach and refactoring process

### Benefits

- **Easier Navigation**: Find specific information without scrolling through 1200+ lines
- **Better Maintenance**: Update specific areas without merge conflicts
- **Clear Separation**: Each plan has single responsibility
- **Onboarding**: New contributors can read relevant sections

### Journal System Established

Created `docs/journals/` directory for session notes and insights:

- Records facts, decisions, and learnings
- Searchable history for future reference
- Captures "why" behind technical decisions
- Helps with memory between sessions

## Documentation Cleanup: PLAN.md and AGENTS.md Separation

### Problem Identified

PLAN.md and AGENTS.md/CLAUDE.md had overlapping content that violated separation of concerns:

- Build commands appeared in both files
- Project overview duplicated
- Unclear which file served which purpose

### Solution

Clarified document responsibilities:

- **AGENTS.md/CLAUDE.md**: Agent behavior (how to code, work, use dev tools)
- **PLAN.md**: Project specification (what the project is, status, roadmap)

### Changes Made

Removed from PLAN.md:

- File structure details (implementation detail)
- Build & Development commands (belong in AGENTS.md as dev tools)
- Build system specifics (implementation detail)
- Success metrics (implementation benchmarks)

PLAN.md now contains only:

- High-level project overview and vision
- Current status and health indicators
- Links to detailed architectural sub-plans
- Active issues and feature roadmap
- Historical reference pointer

Result: PLAN.md reduced from 194 lines to 95 lines with clearer focus.

Moved PLAN.md to `docs/SPEC.md` to better reflect its purpose as project specification rather than a planning document.

### Key Learning

**Documentation Separation of Concerns**: Keeping "what the project is" (PLAN.md) separate from "how to work on it" (AGENTS.md) prevents duplication and makes both documents easier to maintain. Specification goes in PLAN.md, workflow and tooling goes in AGENTS.md.

## Reflection

Today was productive - completed a focused refactoring task (Issue #66) following an established pattern, then improved project documentation structure. The new plans and journal structure should make it easier to work on the project going forward, especially as it grows in complexity.

The fact that all 305 tests continued passing throughout the refactoring demonstrates the value of our testing strategy. The layered architecture pattern continues to prove its worth.

Documentation cleanup reinforced the importance of clear separation of concerns - not just in code, but in project documentation as well.

## Issue #67 Complete: UINotificationAdapter Pattern Across All Services

Successfully completed the final phase of the UINotificationAdapter migration, eliminating all direct `Notice` usage from services and UI components.

### What We Did

**Problem**: Services and UI components had inconsistent notification handling - some used the UINotificationAdapter pattern while others used direct Obsidian `Notice` calls, violating the adapter pattern and causing testing issues.

**Solution**: Migrated all remaining direct `Notice` usage to the UINotificationAdapter pattern established in previous issues (#55-#57, #60, #65, #66).

### Changes Made

**Services Updated:**

1. `model-validation-service.ts` - 5 Notice usages → adapter (validation errors, connection tests)
2. `model-configuration-service.ts` - 4 Notice usages → adapter (duplicate, delete, verify notifications)
3. `model-config-service.ts` - 1 Notice usage → adapter (save model notification)
4. `menu-service.ts` - Already using adapter (no changes needed)

**UI Components Updated:** 5. `api-key-modal.ts` - 4 Notice usages → adapter (validation errors, save notifications)

**Service Instantiation Points:**

- `add-model-modal.ts` - Updated service instantiations to pass adapter
- `settings.ts` - Updated service instantiations to pass adapter
- `api-key-configuration-service.ts` - Updated modal instantiation to pass adapter
- `settings-ui-service.ts` - Added adapter parameter, passes to modal
- `main.ts` - Changed notificationAdapter from private to public for UI access

**Tests Updated:**

- `model-config-service.test.ts` - Added mock notification adapter
- `model-validation-service.test.ts` - Added mock notification adapter

### Testing Results

- ✅ All 305 tests pass
- ✅ TypeScript compilation succeeds
- ✅ No direct Notice usage remaining (except in adapter implementation itself)
- ✅ Consistent error handling across entire codebase

### Architecture Achievement

This completes the UINotificationAdapter pattern integration across ALL services and UI components:

**Services:**

- ✅ InferenceService
- ✅ MenuService
- ✅ CanvasService
- ✅ ApiKeyConfigurationService
- ✅ ModelValidationService (today)
- ✅ ModelConfigurationService (today)
- ✅ ModelConfigService (today)

**UI Components:**

- ✅ ApiKeyModal (today)
- ✅ Settings components (via services)

The codebase now has 100% consistent notification handling through the adapter pattern.

### Commits

Single atomic commit following conventional commit format:

`refactor: replace direct Notice usage with UINotificationAdapter across all services` (aba4833)

- Closes #67

### Key Learnings

1. **Pattern Completion**: Finishing the adapter pattern migration across the entire codebase provides clean architectural consistency - no more mixed approaches.

2. **Public vs Private Access**: Made `notificationAdapter` public in main plugin class for UI component access. This is appropriate because UI components need direct access to notification functionality, and the adapter is a stable, well-defined interface.

3. **Test Consistency**: All service tests now follow the same pattern with mock notification adapters, making the test suite more maintainable and understandable.

4. **Systematic Migration**: Following the same pattern established in earlier issues made this refactoring straightforward and low-risk - the pattern was proven and we just applied it consistently.

### Impact

- **Better Testability**: All notifications can be tested without mocking Obsidian APIs
- **Consistent UX**: All user-facing notifications use the same adapter, ensuring consistent behavior
- **Maintainability**: Single point of change for notification behavior across entire codebase
- **Architecture Completion**: Foundational refactor is now complete, ready for feature development

## Import Path Standardization

### Problem

The codebase had mixed import patterns - some files used the `src/` alias while others used relative imports. This inconsistency was flagged by Copilot and reduced code maintainability.

### Solution

Standardized all imports to use consistent relative paths, removing dependency on path aliases.

### Changes Made

Replaced `src/` alias imports with relative paths in 7 files:

- `tests/unit/model-validation.test.ts`
- `src/ui/add-model-modal.ts`
- `src/ui/api-key-modal.ts`
- `src/services/model-configuration-service.ts`
- `src/services/model-validation-service.ts`
- `src/lib/model-validation.ts`
- `src/contexts/settings-context.tsx`

### Testing Results

- ✅ TypeScript compilation passes
- ✅ All imports resolve correctly
- ✅ No runtime impact

### Commits

`refactor: standardize import paths to use relative imports` (6d5dad0)

### Key Learning

**Import Consistency**: Using consistent import patterns throughout the codebase improves readability and reduces confusion. Relative imports are explicit about file relationships and don't require path alias configuration.

## Bug Fix: Horizontal Context with Bidirectional Edges

### Problem

Horizontal context nodes (sidenotes) were not being included when edges pointed FROM the parent chain node TO the context node (right-side connections). Only left-side connections (context pointing TO parent) worked.

**Example**: In a canvas with `center -> sidenote -> sidenote_chain`, when processing a request from `center`, only `center`'s content was included. The `sidenote` (value 3) was missing, though `sidenote_chain` (value 23) was correctly excluded.

### Root Cause

The `getHorizontalContext` function in `src/canvas/walker.ts:128-155` used this logic:

```typescript
if (edge.toNode === nodeId) {
    horizontalNodes.push(connectedNodeId);
}
```

This only included nodes where edges pointed TO the current node, excluding nodes where edges pointed FROM the current node.

### Investigation Process

Used Systematic Debugging skill to methodically investigate:

**Phase 1: Root Cause Investigation**
- Traced data flow through `canvasGraphWalker` and `getHorizontalContext`
- Identified that edge direction was causing the exclusion

**Phase 2: Pattern Analysis**
- Compared working test cases (context pointing TO parent) with failing scenario (parent pointing TO context)
- Found key difference: edge `fromSide`/`toSide` properties distinguish horizontal vs vertical connections

**Phase 3: Hypothesis**
- Horizontal connections use `left`/`right` sides
- Vertical (parent/child) connections use `top`/`bottom` sides
- Need to check edge sides, not just direction

**Phase 4: Implementation**
- Created failing test case reproducing exact scenario
- Modified logic to check edge sides instead of direction
- Verified all 306 tests pass

### Solution

Changed the logic to use edge sides to distinguish horizontal from vertical connections:

```typescript
const isHorizontalEdge =
    (edge.fromSide === "left" || edge.fromSide === "right") &&
    (edge.toSide === "left" || edge.toSide === "right");

if (!isHorizontalEdge) {
    continue;
}
```

Now horizontal context is included regardless of edge direction, as long as:
1. The edge uses left/right sides (horizontal connection)
2. The node isn't already in the parent chain
3. The node doesn't have chained context from other non-parent-chain nodes

### Changes Made

1. **Walker Logic** (`src/canvas/walker.ts:128-176`):
   - Added edge side checking to distinguish horizontal from vertical connections
   - Simplified logic - removed complex child node detection
   - Better aligns with visual canvas layout

2. **Test Coverage** (`tests/canvas/walker.test.ts:774-845`):
   - Added test case "should include horizontal context regardless of edge direction"
   - Tests exact scenario from bug report
   - Uses text nodes to match real-world usage

### Testing Results

- ✅ All 306 tests pass (new test + all existing tests)
- ✅ TypeScript compilation succeeds
- ✅ Linting passes
- ✅ Edge direction no longer matters for horizontal context
- ✅ Chained context still correctly excluded

### Commits

Two atomic commits:

1. `test: add failing test for bidirectional horizontal context`
   - Reproduces exact bug scenario
   - Shows value 3 missing from context

2. `fix: include horizontal context regardless of edge direction`
   - Uses edge sides (left/right vs top/bottom) to determine context type
   - Simpler, more correct implementation
   - All tests pass

### Key Learnings

1. **Systematic Debugging Works**: Following the 4-phase debugging process (investigate → analyze → hypothesize → implement) led directly to the root cause without thrashing.

2. **Edge Metadata is Semantic**: The `fromSide`/`toSide` properties encode important semantic information about relationship type (horizontal vs vertical), not just visual layout.

3. **Test-Driven Bug Fixes**: Writing the failing test first ensured we fixed the right problem and prevented regressions.

4. **Simpler is Better**: The new solution is simpler than the original (checking edge sides vs complex child node detection) and more correct.
